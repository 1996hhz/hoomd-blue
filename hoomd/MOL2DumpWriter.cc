// Copyright (c) 2009-2016 The Regents of the University of Michigan
// This file is part of the HOOMD-blue project, released under the BSD 3-Clause License.


// Maintainer: joaander

/*! \file MOL2DumpWriter.cc
    \brief Defines the MOL2DumpWriter class
*/



#include "MOL2DumpWriter.h"
#include "BondedGroupData.h"

#include <boost/python.hpp>
using namespace boost::python;

#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <boost/shared_ptr.hpp>

using namespace std;

/*! \param sysdef SystemDefinition containing the ParticleData to dump
    \param fname_base The base file name to write the output to
*/
MOL2DumpWriter::MOL2DumpWriter(boost::shared_ptr<SystemDefinition> sysdef, std::string fname_base)
        : Analyzer(sysdef), m_base_fname(fname_base)
    {
    m_exec_conf->msg->notice(5) << "Constructing MOL2DumpWriter: " << fname_base << endl;
    }

MOL2DumpWriter::~MOL2DumpWriter()
    {
    m_exec_conf->msg->notice(5) << "Destroying PDBDumpWriter" << endl;
    }

/*! \param timestep Current time step of the simulation
    Writes a snapshot of the current state of the ParticleData to a mol2 file
*/
void MOL2DumpWriter::analyze(unsigned int timestep)
    {
    if (m_prof)
        m_prof->push("Dump MOL2");

    ostringstream full_fname;
    string filetype = ".mol2";

    // Generate a filename with the timestep padded to ten zeros
    full_fname << m_base_fname << "." << setfill('0') << setw(10) << timestep << filetype;
    writeFile(full_fname.str());

    if (m_prof)
        m_prof->pop();
    }

/*! \param fname File name to write
*/
void MOL2DumpWriter::writeFile(std::string fname)
    {
    // open the file for writing
    ofstream f(fname.c_str());

    if (!f.good())
        {
        m_exec_conf->msg->error() << "dump.mol2: Unable to open dump file for writing: " << fname << endl;
        throw runtime_error("Error writting mol2 dump file");
        }

    // acquire the particle data
    ArrayHandle<Scalar4> h_pos(m_pdata->getPositions(), access_location::host, access_mode::read);
    ArrayHandle<unsigned int> h_rtag(m_pdata->getRTags(), access_location::host, access_mode::read);

    // write the header
    f << "@<TRIPOS>MOLECULE" << "\n";
    f << "Generated by HOOMD" << "\n";
    int num_bonds = 1;
    boost::shared_ptr<BondData> bond_data = m_sysdef->getBondData();
    if (bond_data && bond_data->getN() > 0)
        num_bonds = bond_data->getN();

    f << m_pdata->getN() << " " << num_bonds << "\n";
    f << "NO_CHARGES" << "\n";

    f << "@<TRIPOS>ATOM" << "\n";
    for (unsigned int j = 0; j < m_pdata->getN(); j++)
        {
        // use the rtag data to output the particles in the order they were read in
        int i;
        i= h_rtag.data[j];

        // get the coordinates
        Scalar x = (h_pos.data[i].x);
        Scalar y = (h_pos.data[i].y);
        Scalar z = (h_pos.data[i].z);

        // get the type by name
        unsigned int type_id = __scalar_as_int(h_pos.data[i].w);
        string type_name = m_pdata->getNameByType(type_id);

        // this is intended to go to VMD, so limit the type name to 15 characters
        if (type_name.size() > 15)
            {
            m_exec_conf->msg->error() << "dump.mol2: Type name <" << type_name << "> too long: please limit to 15 characters" << endl;
            throw runtime_error("Error writting mol2 dump file");
            }

        f << j+1 << " " << type_name << " " << x << " " << y << " "<< z << " " << type_name << "\n";

        if (!f.good())
            {
            m_exec_conf->msg->error() << "dump.mol2: I/O error while writing MOL2 dump file" << endl;
            throw runtime_error("Error writting mol2 dump file");
            }
        }

    f << "@<TRIPOS>BOND" << "\n";
    if (bond_data && bond_data->getN() > 0)
        {
        for (unsigned int i = 0; i < bond_data->getN(); i++)
            {
            BondData::members_t b = bond_data->getMembersByIndex(i);
            f << i+1 << " " << b.tag[0]+1 << " " << b.tag[1]+1 << " 1" << "\n";
            }
        }
    else
        {
        // write a dummy bond since VMD doesn't like loading mol2 files without bonds
        f << "1 1 2 1" << "\n";
        }

    if (!f.good())
        {
        m_exec_conf->msg->error() << "dump.mol2: I/O error while writing file" << endl;
        throw runtime_error("Error writting mol2 dump file");
        }

    f.close();
    }

void export_MOL2DumpWriter()
    {
    class_<MOL2DumpWriter, boost::shared_ptr<MOL2DumpWriter>, bases<Analyzer>, boost::noncopyable>
    ("MOL2DumpWriter", init< boost::shared_ptr<SystemDefinition>, std::string >())
    .def("writeFile", &MOL2DumpWriter::writeFile)
    ;

    }
