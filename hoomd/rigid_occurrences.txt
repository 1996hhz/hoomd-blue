BoxResizeUpdater.cc:                // intentionally scale both rigid body and free particles, this may waste a few cycles but it enables
BoxResizeUpdater.cc:                // the debug inBox checks to be left as is (otherwise, setRV cannot fixup rigid body positions without
Communicator.cc:        // by now, local particles may have moved outside the box due to the rigid body update
Communicator.h:        GPUArray<Scalar> m_r_ghost_body;         //!< Extra ghost width for rigid bodies
DCDDumpWriter.cc:      m_unwrap_full(false), m_unwrap_rigid(false), m_angle(false),
DCDDumpWriter.cc:        else if (m_unwrap_rigid && snapshot.body[i] != NO_BODY)
DCDDumpWriter.cc:    .def("setUnwrapRigid", &DCDDumpWriter::setUnwrapRigid)
DCDDumpWriter.h:        //! Set whether rigid body coordinates should be written out wrapped or unwrapped.
DCDDumpWriter.h:        void setUnwrapRigid(bool enable)
DCDDumpWriter.h:            m_unwrap_rigid = enable;
DCDDumpWriter.h:        bool m_unwrap_rigid;                //!< True if rigid bodies should be written out unwrapped
GetarDumpWriter.cc:        bool angles, bool dihedrals, bool impropers, bool pairs, bool rigid, bool integrator)
GetarDumpWriter.cc:            impropers, rigid, integrator, pairs);
GetarDumpWriter.cc:            case NeedRigid:
GetarDumpWriter.cc:                neededSnapshots[NeedImproper], neededSnapshots[NeedPair], neededSnapshots[NeedRigid],
GetarDumpWriter.h:        Body,  // particle rigid body index
GetarDumpWriter.h:        NeedRigid,
GetarDumpWriter.h:                    m_prefix += "rigid_body/";
GetarInitializer.cc:        // version. Note that velocity is for particles, not rigid
GetarInitializer.cc:            recGroup = "rigid_body";
ParticleData.cc:                // if requested, do not initialize constituent particles of rigid bodies
ParticleData.cc:            // if requested, do not initialize constituent particles of rigid bodies
ParticleData.cuh://! Sentinel value in \a body to signify that this particle does not belong to a rigid body
ParticleData.h://! Sentinel value in \a body to signify that this particle does not belong to a rigid body
ParticleData.h:    If any computation is unable to supply the appropriate values (i.e. rigid body virial can not be computed
ParticleData.h:    of course) where integration methods like NVERigid will handle updating the degrees of freedom of the composite
ParticleData.h:    by the NeighborList or other classes to compute rigid body interactions correctly. The maximum value
ParticleData.h:    is updated by querying all classes that compute rigid body forces for updated values whenever needed.
ParticleData.h:        /*! Returns true if there are rigid bodies in the system
ParticleData.h:        bool hasRigidBodies() const
ParticleData.h:        GlobalArray<unsigned int> m_body;              //!< rigid body ids
ParticleData.h:        GlobalArray<unsigned int> m_body_alt;          //!< rigid body ids (swap-in)
ParticleGroup.cc:// ParticleSelectorRigid
ParticleGroup.cc:    \param rigid true selects particles that are in rigid bodies, false selects particles that are not part of a body
ParticleGroup.cc:ParticleSelectorRigid::ParticleSelectorRigid(std::shared_ptr<SystemDefinition> sysdef,
ParticleGroup.cc:                                             bool rigid)
ParticleGroup.cc:    : ParticleSelector(sysdef), m_rigid(rigid)
ParticleGroup.cc:    \returns true if the type of particle \a tag meets the rigid criteria selected
ParticleGroup.cc:bool ParticleSelectorRigid::isSelected(unsigned int tag) const
ParticleGroup.cc:    if (m_rigid && body != NO_BODY)
ParticleGroup.cc:    if (!m_rigid && body == NO_BODY)
ParticleGroup.cc:// ParticleSelectorRigidCenter
ParticleGroup.cc:ParticleSelectorRigidCenter::ParticleSelectorRigidCenter(std::shared_ptr<SystemDefinition> sysdef)
ParticleGroup.cc:    \returns true if the type of particle \a tag is a center particle of a rigid body
ParticleGroup.cc:bool ParticleSelectorRigidCenter::isSelected(unsigned int tag) const
ParticleGroup.cc:    py::class_<ParticleSelectorRigid, std::shared_ptr<ParticleSelectorRigid> >(m,"ParticleSelectorRigid",py::base<ParticleSelector>())
ParticleGroup.cc:    py::class_<ParticleSelectorRigidCenter, std::shared_ptr<ParticleSelectorRigidCenter> >(m,"ParticleSelectorRigidCenter",py::base<ParticleSelector>())
ParticleGroup.h://! Select particles based on their rigid body
ParticleGroup.h:class PYBIND11_EXPORT ParticleSelectorRigid : public ParticleSelector
ParticleGroup.h:        ParticleSelectorRigid(std::shared_ptr<SystemDefinition> sysdef, bool rigid);
ParticleGroup.h:        virtual ~ParticleSelectorRigid() {}
ParticleGroup.h:        bool m_rigid;   //!< true if we should select rigid bodies, false if we should select non-rigid particles
ParticleGroup.h:class PYBIND11_EXPORT ParticleSelectorRigidCenter : public ParticleSelector
ParticleGroup.h:        ParticleSelectorRigidCenter(std::shared_ptr<SystemDefinition> sysdef);
ParticleGroup.h:        virtual ~ParticleSelectorRigidCenter() {}
compute.py:      where :math:`\vec{F}_{ij}` are pairwise forces between particles and :math:`\vec{F}_k` are forces due to explicit constraints, implicit rigid
data.py:        body (int): Rigid body id (-1 for free particles).
dem/DEM2DForceCompute.h:            flags[comm_flag::net_torque] = 1; // only used with rigid bodies
dem/DEM3DForceCompute.h:            flags[comm_flag::net_torque] = 1; // only used with rigid bodies
deprecated/POSDumpWriter.h:        //! Set whether rigid body coordinates should be written out wrapped or unwrapped.
deprecated/POSDumpWriter.h:        void setUnwrapRigid(bool enable)
deprecated/POSDumpWriter.h:            m_unwrap_rigid = enable;
deprecated/POSDumpWriter.h:        bool m_unwrap_rigid;     //!< If true, unwrap rigid bodies
deprecated/dump.py:        unwrap_rigid (bool): When False, (the default) individual particles are written inside
deprecated/dump.py:                             the simulation box which breaks up rigid bodies near box boundaries. When True,
deprecated/dump.py:                             particles belonging to the same rigid body will be unwrapped so that the body
deprecated/dump.py:    def __init__(self, filename, period=None, unwrap_rigid=False, phase=0, addInfo=None):
deprecated/dump.py:        self.cpp_analyzer.setUnwrapRigid(unwrap_rigid);
deprecated/dump.py:        self.unwrap_rigid = unwrap_rigid
deprecated/dump.py:        self.metadata_fields = ['filename', 'period', 'unwrap_rigid']
deprecated/POSDumpWriter.cc:        : Analyzer(sysdef), m_unwrap_rigid(false), m_write_info(false)
deprecated/POSDumpWriter.cc:        if (m_unwrap_rigid && snap.body[j] != NO_BODY)
deprecated/POSDumpWriter.cc:        .def("setUnwrapRigid", &POSDumpWriter::setUnwrapRigid)
dump.py:        unwrap_rigid (bool): When False, (the default) individual particles are written inside the simulation box which
dump.py:               breaks up rigid bodies near box boundaries. When True, particles belonging to the same rigid body will be
dump.py:               some particles may be written just outside it. *unwrap_rigid* is ignored when *unwrap_full* is True.
dump.py:    def __init__(self, filename, period, group=None, overwrite=False, unwrap_full=False, unwrap_rigid=False, angle_z=False, phase=0):
dump.py:        self.cpp_analyzer.setUnwrapRigid(unwrap_rigid);
group.py:    * :py:func:`hoomd.group.nonrigid()`
group.py:    * :py:func:`hoomd.group.rigid()`
group.py:def rigid_center():
group.py:    R""" Groups particles that are center particles of rigid bodies.
group.py:    Creates a particle group from particles. All particles that are central particles of rigid bodies be added to the group.
group.py:    The group is always named 'rigid_center'.
group.py:        rigid = group.rigid_center()
group.py:    name = 'rigid_center';
group.py:    selector = _hoomd.ParticleSelectorRigidCenter(hoomd.context.current.system_definition);
group.py:def nonrigid():
group.py:    R""" Groups particles that do not belong to rigid bodies.
group.py:    Creates a particle group from particles. All particles that **do not** belong to a rigid body will be added to
group.py:    the group. The group is always named 'nonrigid'.
group.py:        nonrigid = group.nonrigid()
group.py:    name = 'nonrigid';
group.py:    selector = _hoomd.ParticleSelectorRigid(hoomd.context.current.system_definition, False);
group.py:def rigid():
group.py:    R""" Groups particles that belong to rigid bodies.
group.py:    Creates a particle group from particles. All particles that belong to a rigid body will be added to the group.
group.py:    The group is always named 'rigid'.
group.py:        rigid = group.rigid()
group.py:    name = 'rigid';
group.py:    selector = _hoomd.ParticleSelectorRigid(hoomd.context.current.system_definition,True);
init.py:       "body", "int", "(N,)", "particle rigid body index"
md/ConstraintEllipsoid.cc:            m_exec_conf->msg->error() << "constrain.ellipsoid: Particle " << h_tag.data[j] << " belongs to a rigid body"
md/PPPMForceComputeGPU.cc:    // apply rigid body correction
md/PPPMForceCompute.cc:    // apply rigid body correction
md/PPPMForceCompute.cc:            m_exec_conf->msg->notice(2) << "PPPM: calculating rigid body correction (N^2)" << std::endl;
md/PPPMForceCompute.cc:    if (m_prof) m_prof->push("rigid body correction");
md/PPPMForceCompute.cc:            m_exec_conf->msg->warning() << "charge.pppm: Operating on a group which is not group.all(). Rigid body self-energies may be wrong." << std::endl;
md/test/test_nve_integrator.cc://! Need work on NVEUpdaterGPU with rigid bodies to test these cases
md/PPPMForceCompute.h:        Scalar m_body_energy;                      //!< Energy correction due to rigid body exclusions
md/PPPMForceCompute.h:        //! Compute rigid body correction
md/ActiveForceComputeGPU.cu:            // torque vector rotates rigidly along with force vector
md/ActiveForceComputeGPU.cu:            // torque vector rotates rigidly along with force vector
md/test-py/test_constrain_rigid.py:# test the md.constrain.rigid() functionality
md/test-py/test_constrain_rigid.py:class test_constrain_rigid(unittest.TestCase):
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        self.assertRaises(RuntimeError,rigid.set_param,'A', types=['A_const']*3, positions=[(1,2,3),(4,5,6)])
md/test-py/test_constrain_rigid.py:        self.assertRaises(RuntimeError,rigid.set_param,'A', types=['A_const']*2, positions=[(1,2,3),(4,5,6)], charges=[0])
md/test-py/test_constrain_rigid.py:        self.assertRaises(RuntimeError,rigid.set_param,'A', types=['A_const']*2, positions=[(1,2,3),(4,5,6)], diameters=[0])
md/test-py/test_constrain_rigid.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        rigid.set_param('A', types=['A_const','A_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        rigid.set_param('B', types=['B_const','B_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        rigid.create_bodies()
md/test-py/test_constrain_rigid.py:        center = group.rigid_center()
md/test-py/test_constrain_rigid.py:        del rigid
md/test-py/test_constrain_rigid.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        rigid.set_param('A', types=['A_const','A_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        rigid.set_param('B', types=['B_const','B_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        rigid.create_bodies()
md/test-py/test_constrain_rigid.py:        center = group.rigid_center()
md/test-py/test_constrain_rigid.py:        del rigid
md/test-py/test_constrain_rigid.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        rigid.set_param('A', types=['A_const','A_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)],diameters=[1,2],charges=[-1,1])
md/test-py/test_constrain_rigid.py:        rigid.set_param('B', types=['B_const','B_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)],diameters=[3,4],charges=[-2,2])
md/test-py/test_constrain_rigid.py:        rigid.create_bodies()
md/test-py/test_constrain_rigid.py:        center = group.rigid_center()
md/test-py/test_constrain_rigid.py:        # create rigid bodies
md/test-py/test_constrain_rigid.py:        # validate rigid bodies
md/test-py/test_constrain_rigid.py:        del rigid
md/test-py/test_constrain_rigid.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        rigid.set_param('A', types=['A_const','A_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        rigid.set_param('B', types=['B_const','B_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        rigid.set_param('A', types=['A_const','A_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:        rigid.set_param('B', types=['B_const','B_const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:    nve = md.integrate.nve(group=group.rigid_center())
md/test-py/test_constrain_rigid.py:    rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:    rigid.set_param('A', types=['const','const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/test-py/test_constrain_rigid.py:    rigid.create_bodies()
md/test-py/test_constrain_rigid.py:class test_constrain_rigid_self_interactions(unittest.TestCase):
md/test-py/test_constrain_rigid.py:# test that mixtures of rigid and nonrigid particles are possible
md/test-py/test_constrain_rigid.py:class test_constrain_rigid_nonrigid(unittest.TestCase):
md/test-py/test_constrain_rigid.py:    def test_rigid_nonrigid(self):
md/test-py/test_constrain_rigid.py:        rigid = md.constrain.rigid()
md/test-py/test_constrain_rigid.py:        rigid.set_param('A',types=['A_const']*2,positions=[(-.5,0,0),(.5,0,0)])
md/test-py/test_constrain_rigid.py:        rigid.create_bodies()
md/test-py/test_constrain_rigid.py:        center = group.rigid_center()
md/test-py/test_constrain_rigid.py:        nonrigid = group.nonrigid()
md/test-py/test_constrain_rigid.py:        g = group.union(a=center,b=nonrigid, name='intgroup')
md/test-py/test_charge_pppm.py:class charge_pppm_rigid_body_test(unittest.TestCase):
md/test-py/test_charge_pppm.py:        self.rigid = md.constrain.rigid()
md/test-py/test_charge_pppm.py:        self.rigid.set_param('A',types=['A1']*2,positions=[(0,0,0),(0,0,1.2)],charges=[-1,1])
md/test-py/test_charge_pppm.py:        # create rigid particles
md/test-py/test_charge_pppm.py:        self.rigid.create_bodies()
md/test-py/test_charge_pppm.py:        md.integrate.nve(group.rigid_center());
md/test-py/test_charge_pppm.py:        # pairwise forces on a rigid body cancel out
md/test-py/test_charge_pppm.py:    # test PPPM for Yukawa interaction with rigid body exclusions
md/test-py/test_charge_pppm.py:        # create rigid particles
md/test-py/test_charge_pppm.py:        self.rigid.create_bodies()
md/test-py/test_charge_pppm.py:        md.integrate.nve(group.rigid_center());
md/test-py/test_charge_pppm.py:        # pairwise forces on a rigid body cancel out
md/test-py/test_charge_pppm.py:        del self.rigid
md/ForceCompositeGPU.cc:        m_prof->push(m_exec_conf, "constrain_rigid");
md/ForceCompositeGPU.cc:    // access rigid body definition
md/ForceCompositeGPU.cc:    ArrayHandle<unsigned int> d_rigid_center(m_rigid_center, access_location::device, access_mode::read);
md/ForceCompositeGPU.cc:        gpu_rigid_force(d_force.data,
md/ForceCompositeGPU.cc:                        d_rigid_center.data,
md/ForceCompositeGPU.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Composite particle with body tag " << flag.x-1 << " incomplete"
md/ForceCompositeGPU.cc:        gpu_rigid_virial(d_virial.data,
md/ForceCompositeGPU.cc:        m_prof->push(m_exec_conf, "constrain_rigid");
md/ForceCompositeGPU.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Particle " << tag << " part of composite body " << body_id << " is missing central particle"
md/ForceCompositeGPU.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Composite particle with body id " << body_id << " incomplete"
md/ForceCompositeGPU.cc:void ForceCompositeGPU::findRigidCenters()
md/ForceCompositeGPU.cc:    m_rigid_center.resize(m_pdata->getN());
md/ForceCompositeGPU.cc:    ArrayHandle<unsigned int> d_rigid_center(m_rigid_center, access_location::device, access_mode::overwrite);
md/ForceCompositeGPU.cc:    unsigned int n_rigid = 0;
md/ForceCompositeGPU.cc:    gpu_find_rigid_centers(d_body.data,
md/ForceCompositeGPU.cc:                        d_rigid_center.data,
md/ForceCompositeGPU.cc:                        n_rigid);
md/ForceCompositeGPU.cc:    // distribute rigid body centers over GPUs
md/ForceCompositeGPU.cc:    m_gpu_partition.setN(n_rigid);
md/ForceCompositeGPU.cc:        GlobalVector<unsigned int> rigid_center(m_exec_conf);
md/ForceCompositeGPU.cc:        m_rigid_center.swap(rigid_center);
md/ForceCompositeGPU.cc:        TAG_ALLOCATION(m_rigid_center);
md/nlist.py:or for belonging to the same rigid body (see :py:meth:`nlist.reset_exclusions()`).
md/nlist.py:        - Particles that are in the same rigid body.
md/ForceCompositeGPU.h:    \brief Implementation of a rigid body force compute, GPU version
md/ForceCompositeGPU.h:        //! Helper kernel to sort rigid bodies by their center particles
md/ForceCompositeGPU.h:        virtual void findRigidCenters();
md/ForceCompositeGPU.h:                findRigidCenters();
md/ForceCompositeGPU.h:        GPUPartition m_gpu_partition;               //!< Partition of the rigid bodies
md/ForceCompositeGPU.h:        GlobalVector<unsigned int> m_rigid_center;  //!< Contains particle indices of all central particles
md/QuaternionMath.h://! Compute orientation (ex_space, ey_space, ez_space) from quaternion- re-implement from RigidData for self-containing purposes
md/ForceComposite.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Invalid rigid body type." << std::endl;
md/ForceComposite.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Constituent particle lists"
md/ForceComposite.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Charges are non-empty but of different"
md/ForceComposite.cc:        m_exec_conf->msg->error() << "constrain.rigid(): Diameters are non-empty but of different"
md/ForceComposite.cc:void ForceComposite::validateRigidBodies(bool create)
md/ForceComposite.cc:        // check validity of rigid body types: no nested rigid bodies
md/ForceComposite.cc:                        m_exec_conf->msg->error() << "constrain.rigid(): A rigid body type may not contain constituent particles "
md/ForceComposite.cc:                            << "that are also rigid bodies!" << std::endl;
md/ForceComposite.cc:        // constituent particles added as rigid body copies
md/ForceComposite.cc:                            m_exec_conf->msg->error() << "constrain.rigid(): Central particles must have a body tag identical to their contiguous tag." << std::endl;
md/ForceComposite.cc:                            throw std::runtime_error("Error validating rigid bodies\n");
md/ForceComposite.cc:                            m_exec_conf->msg->error() << "constrain.rigid(): Constituent particle body tags must point to the center particle." << std::endl;
md/ForceComposite.cc:                            throw std::runtime_error("Error validating rigid bodies\n");
md/ForceComposite.cc:                                m_exec_conf->msg->error() << "constrain.rigid(): Central particle " << snap.body[i]
md/ForceComposite.cc:                                throw std::runtime_error("Error validating rigid bodies\n");
md/ForceComposite.cc:                                m_exec_conf->msg->error() << "constrain.rigid(): Number of constituent particles for body " << snap.body[i] << " exceeds definition"
md/ForceComposite.cc:                                throw std::runtime_error("Error validating rigid bodies\n");
md/ForceComposite.cc:                                m_exec_conf->msg->error() << "constrain.rigid(): Constituent particle types must be consistent with rigid body parameters." << std::endl;
md/ForceComposite.cc:                                throw std::runtime_error("Error validating rigid bodies\n");
md/ForceComposite.cc:                        m_exec_conf->msg->error() << "constrain.rigid(): Incomplete rigid body with only " << it->second << " constituent particles "
md/ForceComposite.cc:                        throw std::runtime_error("Error validating rigid bodies\n");
md/ForceComposite.cc:                << "constrain.rigid(): Removing all particles part of rigid bodies (except central particles)."
md/ForceComposite.cc:            // re-initialize, removing rigid bodies
md/ForceComposite.cc:                            // wrap into box, allowing rigid bodies to span multiple images
md/ForceComposite.cc:            m_exec_conf->msg->notice(2) << "constrain.rigid(): Creating " << nbodies << " rigid bodies (adding "
md/ForceComposite.cc:                            // wrap into box, allowing rigid bodies to span multiple images
md/ForceComposite.cc:    // access rigid body definition
md/ForceComposite.cc:                    m_exec_conf->msg->error() << "constrain.rigid(): Composite particle with body tag " << central_tag << " incomplete"
md/ForceComposite.cc:                // fetch relative position from rigid body definition
md/ForceComposite.cc:                /* from previous rigid body implementation: Access Torque elements from a single particle. Right now I will am assuming that the particle
md/ForceComposite.cc:                    and rigid body reference frames are the same. Probably have to rotate first.
md/ForceComposite.cc:/* Set position and velocity of constituent particles in rigid bodies in the 1st or second half of integration on the CPU
md/ForceComposite.cc:            m_exec_conf->msg->error() << "constrain.rigid(): Missing central particle tag " << central_tag << "!"
md/ForceComposite.cc:                m_exec_conf->msg->error() << "constrain.rigid(): Composite particle with body tag " << central_tag << " incomplete"
md/ForceComposite.cc:        // wrap into box, allowing rigid bodies to span multiple images
md/ForceComposite.cc:        .def("validateRigidBodies", &ForceComposite::validateRigidBodies)
md/ZeroMomentumUpdater.cc:    // add up the momentum of every free particle and every central particle of a rigid body
md/NeighborList.cc:    bool has_bodies = m_pdata->hasRigidBodies();
md/NeighborList.cc:        m_exec_conf->msg->warning() << "Disabling the body exclusion will cause rigid bodies to behave erratically" << endl
md/constrain.py:class rigid(_constraint_force):
md/constrain.py:    R""" Constrain particles in rigid bodies.
md/constrain.py:    Rigid bodies are defined by a single central particle and a number of
md/constrain.py:    mass and moment of inertia of the rigid body (constituent particle mass is ignored).
md/constrain.py:    The central particle is at the center of mass of the rigid body and the orientation quaternion defines the rotation
md/constrain.py:    moment of inertia is diagonal. You specify the constituent particles to :py:class:`rigid` for each type of body
md/constrain.py:    in body coordinates. Then, :py:class:`rigid` takes control of those particles, and sets their position and
md/constrain.py:    :py:class:`rigid` also transfers forces and torques from constituent particles to the central
md/constrain.py:    central particles (representing the whole rigid body) forward in time.
md/constrain.py:    :py:class:`rigid` accepts one local body environment per body type. The type of a body is the particle type
md/constrain.py:    Example that creates rigid rods::
md/constrain.py:        rigid = hoomd.md.constrain.rigid();
md/constrain.py:        rigid.set_param('R',
md/constrain.py:        rigid.create_bodies()
md/constrain.py:        particles in the initial configuration, or bonds connect to constituent particles, rigid bodies should be
md/constrain.py:    of a rigid body must have a lower tag than all of its constituent particles. Constituent particles follow in
md/constrain.py:    Additionally, you must set the ``body`` field for each of the particles in the rigid body to the tag of
md/constrain.py:    not belong to a rigid body. After setting an initial configuration that contains properly defined bodies and
md/constrain.py:    Most integrators in HOOMD support the integration of rotational degrees of freedom. When there are rigid bodies
md/constrain.py:    present in the system, do not apply integrators to the constituent particles, only the central and non-rigid
md/constrain.py:        rigid = hoomd.group.rigid_center();
md/constrain.py:        hoomd.md.integrate.langevin(group=rigid, kT=1.0, seed=42);
md/constrain.py:    HOOMD computes thermodynamic quantities (temperature, kinetic energy, etc...) appropriately when there are rigid
md/constrain.py:    .. rubric:: Restarting simulations with rigid bodies.
md/constrain.py:    specify the same local body space environment to :py:class:`rigid` as you did in the earlier simulation.
md/constrain.py:        R""" Set constituent particle types and coordinates for a rigid body.
md/constrain.py:            rigid = constrain.rigid()
md/constrain.py:            rigid.set_param('A', types = ['A_const', 'A_const'], positions = [(0,0,1),(0,0,-1)])
md/constrain.py:            rigid.set_param('B', types = ['B_const', 'B_const'], positions = [(0,0,.5),(0,0,-.5)])
md/constrain.py:            raise RuntimeError('Error setting up parameters for constrain.rigid()')
md/constrain.py:            raise RuntimeError('Error setting up parameters for constrain.rigid()')
md/constrain.py:                raise RuntimeError('Error setting up parameters for constrain.rigid()')
md/constrain.py:                raise RuntimeError('Error setting up parameters for constrain.rigid()')
md/constrain.py:                    raise RuntimeError('Error setting up parameters for constrain.rigid()')
md/constrain.py:        R""" Create copies of rigid bodies.
md/constrain.py:            create (bool): When True, create rigid bodies, otherwise validate existing ones.
md/constrain.py:        self.cpp_force.validateRigidBodies(create)
md/constrain.py:        self.cpp_force.validateRigidBodies(False)
md/constrain.py:        # validate copies of rigid bodies
md/ForceCompositeGPU.cuh:cudaError_t gpu_rigid_force(Scalar4* d_force,
md/ForceCompositeGPU.cuh:                 const unsigned int *d_rigid_center,
md/ForceCompositeGPU.cuh:cudaError_t gpu_rigid_virial(Scalar* d_virial,
md/ForceCompositeGPU.cuh:cudaError_t gpu_find_rigid_centers(const unsigned int *d_body,
md/ForceCompositeGPU.cuh:                                unsigned int *d_rigid_center,
md/ForceCompositeGPU.cuh:                                unsigned int &n_rigid);
md/IntegrationMethodTwoStep.cc:                m_exec_conf->msg->error() << "Particle " << tag << " belongs to a rigid body, but is not its center particle. "
md/IntegrationMethodTwoStep.cc:        /* Generate a new random angular momentum if the particle is a rigid
md/IntegratorTwoStep.h:    of freedom (rigid bodies).
md/IntegratorTwoStep.h:        //! Updates the rigid body constituent particles
md/IntegratorTwoStep.h:        virtual void updateRigidBodies(unsigned int timestep);
md/Enforce2DUpdater.cc:    // for rigid bodies, zero x / y components of omega/angmom/torque:
md/AnisoPotentialPair.h:    // with rigid bodies, include net torque
md/NeighborList.h:            // detect if there are any rigid bodies in the system
md/NeighborList.h:            bool has_bodies = m_pdata->hasRigidBodies();
md/ForceComposite.h:    \brief Implementation of a rigid body force compute
md/ForceComposite.h:    Rigid body data is stored per type. Every rigid body is defined by a unique central particle of
md/ForceComposite.h:    the rigid body type. A rigid body can only have one particle of that type.
md/ForceComposite.h:    Nested rigid bodies are not supported, i.e. when a rigid body contains a rigid body ptl of another type.
md/ForceComposite.h:        //! Set the coordinates for the template for a rigid body of type typeid
md/ForceComposite.h:        /*! \param body_type The type of rigid body
md/ForceComposite.h:        //! Validate or create copies of rigid body constituent particles
md/ForceComposite.h:        /*! \param create If true, expand central particle types into rigid bodies, modifying the number of particles
md/ForceComposite.h:        virtual void validateRigidBodies(bool create=false);
md/ForceComposite.h:        //! Returns the maximum diameter over all rigid bodies
md/ForceComposite.h:        bool m_global_max_d_changed;       //!< True if we updated any rigid body
md/NeighborListStencil.cc:                // skip any particles belonging to the same rigid body if requested
md/ForceCompositeGPU.cu:__global__ void gpu_rigid_force_sliding_kernel(Scalar4* d_force,
md/ForceCompositeGPU.cu:                                                 const unsigned int *d_rigid_center,
md/ForceCompositeGPU.cu:            central_idx[m] = d_rigid_center[group_idx + first_body];
md/ForceCompositeGPU.cu:__global__ void gpu_rigid_virial_sliding_kernel(Scalar* d_virial,
md/ForceCompositeGPU.cu:cudaError_t gpu_rigid_force(Scalar4* d_force,
md/ForceCompositeGPU.cu:                 const unsigned int *d_rigid_center,
md/ForceCompositeGPU.cu:            cudaFuncGetAttributes(&attr, (const void *) gpu_rigid_force_sliding_kernel);
md/ForceCompositeGPU.cu:        gpu_rigid_force_sliding_kernel<<< force_grid, run_block_size, shared_bytes >>>(
md/ForceCompositeGPU.cu:            d_rigid_center,
md/ForceCompositeGPU.cu:cudaError_t gpu_rigid_virial(Scalar* d_virial,
md/ForceCompositeGPU.cu:        cudaFuncGetAttributes(&attr, (const void *) gpu_rigid_virial_sliding_kernel);
md/ForceCompositeGPU.cu:    gpu_rigid_virial_sliding_kernel<<< force_grid, run_block_size, shared_bytes >>>(
md/ForceCompositeGPU.cu:    // wrap into box, allowing rigid bodies to span multiple images
md/ForceCompositeGPU.cu:cudaError_t gpu_find_rigid_centers(const unsigned int *d_body,
md/ForceCompositeGPU.cu:                                unsigned int *d_rigid_center,
md/ForceCompositeGPU.cu:                                unsigned int &n_rigid)
md/ForceCompositeGPU.cu:    thrust::device_ptr<unsigned int> rigid_center(d_rigid_center);
md/ForceCompositeGPU.cu:    // create a contiguos list of rigid center indicies
md/ForceCompositeGPU.cu:                    rigid_center,
md/ForceCompositeGPU.cu:    n_rigid = it - rigid_center;
md/validation/CMakeLists.txt:minimize_fire_rigid.py 0 0
md/validation/CMakeLists.txt:compare_npt_nvt_rigid.py 0 2
md/validation/CMakeLists.txt:minimize_fire_rigid.py 0 0
md/validation/CMakeLists.txt:compare_npt_nvt_rigid.py 0 2
md/validation/bd_angular.py:        rigid = md.constrain.rigid()
md/validation/bd_angular.py:        rigid.set_param('A', types=['+','-'], positions=[(-d/2,0,0),(d/2,0,0)], charges=[1,-1])
md/validation/bd_angular.py:        rigid.create_bodies()
md/validation/bd_angular.py:        bd = md.integrate.brownian(group=group.rigid_center(),kT=1.0,seed=1234)
md/validation/npt_dimer_eos.py:class npt_rigid_validation(unittest.TestCase):
md/validation/npt_dimer_eos.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/validation/npt_dimer_eos.py:        rigid = md.constrain.rigid()
md/validation/npt_dimer_eos.py:        rigid.set_param('A', types=['const','const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/validation/npt_dimer_eos.py:        rigid.create_bodies()
md/validation/npt_dimer_eos.py:        #rigid.disable()
md/validation/npt_dimer_eos.py:        self.center = group.rigid_center()
md/validation/compare_npt_nvt_rigid.py:class npt_rigid_validation(unittest.TestCase):
md/validation/compare_npt_nvt_rigid.py:        # create rigid spherocylinders out of two particles (not including the central particle)
md/validation/compare_npt_nvt_rigid.py:        rigid = md.constrain.rigid()
md/validation/compare_npt_nvt_rigid.py:        rigid.set_param('A', types=['const','const'], positions=[(0,0,-len_cyl/2),(0,0,len_cyl/2)])
md/validation/compare_npt_nvt_rigid.py:        rigid.create_bodies()
md/validation/compare_npt_nvt_rigid.py:        #rigid.disable()
md/validation/compare_npt_nvt_rigid.py:        self.center = group.rigid_center()
md/validation/minimize_fire_rigid.py:class minimize_rigid_test(unittest.TestCase):
md/validation/minimize_fire_rigid.py:        self.rigid = md.constrain.rigid()
md/validation/minimize_fire_rigid.py:        self.rigid.set_param('A', positions=[(-.5,0,0),(.5,0,0)], types=['sphere']*2)
md/validation/minimize_fire_rigid.py:        self.rigid.set_param('B', positions=[(-.5,0,0),(.5,0,0)], types=['sphere']*2)
md/validation/minimize_fire_rigid.py:        self.rigid.create_bodies()
md/NeighborListGPUStencil.cu:                // skip any particles belonging to the same rigid body if requested
md/TwoStepBDGPU.cu:    \param aniso If set true, the system would go through rigid body updates for its orientation
md/TwoStepBDGPU.cu:    \param aniso If set true, the system would go through rigid body updates for its orientation
md/IntegratorTwoStep.cc:        m_comm->getComputeCallbackSignal().disconnect<IntegratorTwoStep, &IntegratorTwoStep::updateRigidBodies>(this);
md/IntegratorTwoStep.cc:        // also updates rigid bodies after ghost updating
md/IntegratorTwoStep.cc:        updateRigidBodies(timestep+1);
md/IntegratorTwoStep.cc:        updateRigidBodies(timestep);
md/IntegratorTwoStep.cc:        comm->getComputeCallbackSignal().connect<IntegratorTwoStep, &IntegratorTwoStep::updateRigidBodies>(this);
md/IntegratorTwoStep.cc://! Updates the rigid body constituent particles
md/IntegratorTwoStep.cc:void IntegratorTwoStep::updateRigidBodies(unsigned int timestep)
md/ConstraintSphere.cc:            m_exec_conf->msg->error() << "constrain.sphere: Particle " << h_tag.data[j] << " belongs to a rigid body"
Binary file md/.ForceComposite.cc.swp matches
mpcd/Integrator.cc:        // also updates rigid bodies after ghost updating
mpcd/Integrator.cc:        updateRigidBodies(timestep+1);
no_body_occurrences.txt:DCDDumpWriter.cc:        else if (m_unwrap_rigid && snapshot.body[i] != NO_BODY)
no_body_occurrences.txt:ParticleGroup.cc:    if (m_rigid && body != NO_BODY)
no_body_occurrences.txt:ParticleGroup.cc:    if (!m_rigid && body == NO_BODY)
no_body_occurrences.txt:deprecated/POSDumpWriter.cc:        if (m_unwrap_rigid && snap.body[j] != NO_BODY)
test/test_particle_group.cc:    // create a group of rigid bodies and check it
test/test_particle_group.cc:    std::shared_ptr<ParticleSelector> selector_body_true(new ParticleSelectorRigid(sysdef, true));
test/test_particle_group.cc:    // create a group of non rigid particles and check it
test/test_particle_group.cc:    std::shared_ptr<ParticleSelector> selector_body_false(new ParticleSelectorRigid(sysdef, false));
test-py/test_dump_dcd.py:    # tests unwrap_rigid option
test-py/test_dump_dcd.py:    def test_unwrap_rigid(self):
test-py/test_dump_dcd.py:        dump.dcd(filename=self.tmp_file, period=100, unwrap_rigid=True);
