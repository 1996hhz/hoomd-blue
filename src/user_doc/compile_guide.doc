
/*
Highly Optimized Object-Oriented Molecular Dynamics (HOOMD) Open
Source Software License
Copyright (c) 2008 Ames Laboratory Iowa State University
All rights reserved.

Redistribution and use of HOOMD, in source and binary forms, with or
without modification, are permitted, provided that the following
conditions are met:

* Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names HOOMD's
contributors may be used to endorse or promote products derived from this
software without specific prior written permission.

Disclaimer

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND
CONTRIBUTORS ``AS IS''  AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 

IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS  BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.
*/


/*! 
\page page_compile_guide Compiling HOOMD

Table of contents:
 - \ref sec_software_req
 - \ref sec_building_windows
 - \ref sec_compiling_linux
 - \ref sec_building_mac
 - \ref sec_build_options

<hr>

\section sec_software_req Software Prerequisites

HOOMD requires a number of prerequisite software packages and libraries to be compiled. 

- Python >= 2.3 
	- <em>optional</em>, but highly recommended to enable scripted simulations
- boost >= 1.32.0
- libz
- CMake >= 2.4
	- >= 2.4.7 is recommended on Mac OS X if doxygen is installed due to an annoying bug in CMake
- Compiler to build source
	- gcc 4.1 on Linux
	- Visual Studio Express 2005 on Windows XP
	- all code is standard c++ and should work on nearly any other (recent) compiler
	- \b note: Visual Studio 9 (aka 2008) does not currently work because of incompatibilities with boost and CUDA
- CUDA Toolkit and the appropriate NVIDIA display driver:
	- <em>optional</em>, but required to enable GPU support
- Subversion
- Doxygen  >= 1.5.6
	- <em>optional</em> but required to build detailed developer documentation

\b Links: <br>
Python - http://www.python.org/ <br>
Boost - http://www.boost.org/ <br>
libz - http://www.zlib.net/ <br>
CMake - http://www.cmake.org/ <br>
CUDA - http://developer.nvidia.com/object/cuda.html <br>
Subversion - http://subversion.tigris.org/ <br>
Doxygen - http://www.stack.nl/~dimitri/doxygen/manual.html <br>

\section sec_building_windows Building on Windows
<b>1. Install prerequisite software</b><br>
Click for detailed instructions: \subpage page_software_req_install_windows

<b>2. Get source code</b>
 - Option 1) download and unpack source code from: http://www.ameslab.gov/hoomd/
 - Option 2) Get the latest development source with subversion 
This command (assuming you've installed the command line svn tools)
\code
 $ svn co https://svn2.assembla.com/svn/hoomd/trunk hoomd
\endcode
will create a directory \e hoomd in your current working directory which will contain
the current development version of the source code. You can perform the same operation
by right clicking a folder and choosing "SVN Checkout..." when using TortoiseSVN.
	
Developers with commit access planning to make changes to the code must use option 2. 

<b>3. Run CMake</b>

You should now have a directory \b hoomd on your hard drive with a subdirectory
\b src containing the source code. CMake must be run to generate the visual studio
project that will compile HOOMD. 
 -# Create a directory \e msvc inside \b hoomd
 -# Start CMake
 -# Set \b C:\\code\\hoomd\\src (modifying to match the location of your hoomd src directory) in
	the box labeled "Where is the Source code".
 -# Set \b C:\\code\\hoomd\\msvc (again, modified to mach the location of your hoomd directory) 
	in the box labeled "Where to build the binaries"
 -# You should now have a screen that looks like this: \image html cmake_windows_initial.png
 -# Click configure and a dialog pops up: \image html cmake_windows_generator.png
 -# Select the IDE you installed (most likely Visual Studio 8 2005) and click OK.
 -# After a short wait while CMake should display a screen that looks like this: \image html cmake_windows_firstpress.png
	If you received an error message instead, it is possible that you are missing one of the
	prerequisite software packages or it is installed to a non-standard location. In the second case,
	you can click on the text box with CMAKE-SOMETHING-NOTFOUND in it and specify the full path
	to the corresponding file or directory.
 -# You can configure any of the build options on this screen to your liking. 
	See \ref sec_build_options for more information on what these options do.
 -# Click configure again to make sure all settings are up to date and then click OK
	to generate the project file and exit CMake.

<b>4. Compile HOOMD</b><br>
Open up the \b HOOMD.sln project in visual studio. Press F7 (or use the GUI build button)
to build all executables. You can also make a single target the active project
(right click and choose set as startup project) and press F7 to build
only it. 

Source can be modified in visual studio, but any files added to the project must 
be done via CMake. In most cases, a file can be added simply by placing it in the 
proper directory and then rerunning CMake.

If you have a system with more than 1 CPU core, you can greatly improve the performance
of the build by making use of all cores. In VS2005, navigate to the menu item <b>Tools</b>-\><b>Options</b>. 
In the left tab, select <b>Projects And Solutions</b>-\><b>Build and Run</b>. Set the value for the
<b>maximum number of parallel project builds</b> to be the total number of CPU cores in your system.
There is more information at http://msdn2.microsoft.com/en-us/library/y0xettzf.aspx .

<hr>

\section sec_compiling_linux Compiling on linux

<b>1. Install prerequisite software</b><br>
Click for detailed instructions: \subpage page_software_req_install_linux

<b>2. Get source code</b>
 - Option 1) download and unpack source code from: http://www.ameslab.gov/hoomd/
 - Option 2) Get the latest development source with subversion 
This command
\code
 $ svn co https://svn2.assembla.com/svn/hoomd/trunk hoomd
\endcode
will create a directory \e hoomd in your current working directory which will contain
the current development version of the source code.

<b>3. Run CMake</b><br>
CMake needs to be run to generate the make files to compile HOOMD.
\code
 $ cd hoomd
 $ mkdir bin
 $ cd bin
 $ ccmake ../src
\endcode

You will then see a screen that looks like this:
\image html cmake_linux_initial.png

Press the 'c' key to configure. You should now see a screen like this:
\image html cmake_linux_firstpress.png

To generate the makefiles now, press 'c' again to ensure the configure is up to date 
and then press the 'g' key. CMake will exit back to the command line. 

You can also scroll down with the arrow keys and change any of the OFF/ON options
to control whether certain features are compiled in. You must press 'c' after 
any change. Note that in some cases, changing an option to ON will cause other
options to appear. There are also a few options controlled by changing text strings.

See \ref sec_build_options for more information on what these options do.

It is possible that some of your libraries may be in non-standard paths. If this is
the case, CMake will report an error after you press 'c'. The offending library 
will be labeled something like CMAKE_LIB_NOTFOUND. If you know where the library is, 
you can specify the \b full path here and press 'c' again.  

<b>4. Compile HOOMD</b><br>
CMake generated make files for make. Just run
\code
 $ make -j4
\endcode
in the \b bin directory to compile everything and generate this documentation. The -j4 option lets
make compile 4 files at once. It's safe to set the value to twice the number of CPU 
cores in your system. HOOMD compiles in seconds on an 8-core 3.0GHz Xeon :)

<hr>

\section sec_building_mac Building on Mac OSX
<b>1. Install prerequisite software</b><br>
Click for detailed instructions: \subpage page_software_req_install_mac

<b>2. Get source code</b>
 - Option 1) download and unpack source code from: http://www.ameslab.gov/hoomd/
 - Option 2) Get the latest development source with subversion 
This command
\code
 $ svn co https://svn2.assembla.com/svn/hoomd/trunk hoomd
\endcode
will create a directory \e hoomd in your current working directory which will contain
the current development version of the source code.

<b>3. Run CMake</b><br>
First, create a directory to hold the compiled object files and executables.
\code
 $ cd hoomd
 $ mkdir bin
 $ cd bin
\endcode
CMake needs to be run in order to generate the build environment. You have two
options here. If there is a particular code editor you prefer and you want to 
compile by running \e make on the command line, just run
\code
 $ ccmake ../src
\endcode
If you would rather use XCode as an IDE, run
\code
 $ ccmake -G Xcode ../src
\endcode
to generate an XCode project file.

You will then see a screen that looks like this:
\image html cmake_mac_initial.png

Press the 'c' key to configure. You should now see a screen like this, though it may be slightly different if you are generating a make file and not an XCode project:
\image html cmake_mac_firstpress.png

To generate the makefiles now (or the XCode project), press 'c' again to ensure the configure is up to date 
and then press the 'g' key. CMake will exit back to the command line. 

You can also scroll down with the arrow keys and change any of the OFF/ON options
to control whether certain features are compiled in. You must press 'c' after 
any change. Note that in some cases, changing an option to ON will cause other
options to appear. There are also a few options controlled by changing text strings.

See \ref sec_build_options for more information on what these options do.

It is possible that some of your libraries may be in non-standard paths. If this is
the case, CMake will report an error after you press 'c'. The offending library 
will be labeled something like CMAKE_LIB_NOTFOUND. If you know where the library is, 
you can specify the \b full path here and press 'c' again.  	

<b>4. Compile HOOMD</b><br>
If you generated make files, just run
\code
 $ make -j4
\endcode
in the \b bin directory to compile everything and generate this documentation. 
The -j4 option lets make compile 4 files at once. It's safe to set the value to twice the number of CPU 
cores in your system. HOOMD compiles in seconds on an 8-core 3.0GHz Xeon :)

If you generated an XCode project, open it in XCode and click the build button
to compile HOOMD. Note that while source code can be edited via XCode, any 
files added to the project must be done with CMake, not the XCode project
management. In most cases, this can be done by simply adding the file to the 
proper directory and rerunning CMake.

\section sec_build_options Build options
Here is a list of all the build options that can be changed by CMake.
 - \b CMAKE_BUILD_TYPE - sets the build type (Makefile generation only, XCode and 
 		Visual Studio can change the build type from within their GUIs)
	- \b Debug - Compiles debug information into the library and executables. 
		Enables asserts to check for programming mistakes. HOOMD will run 
		\e very slow if compiled in Debug mode, but problems are easier to
		identify.
	- \b Release - All compiler optimizations are enabled and asserts are removed.
		Recommended for production builds: required for any benchmarking.
 - \b USE_DOXYGEN - enables the generation of detailed developer documentation
 	- Requires doxygen to be installed
 - \b SINGLE_PRECISION - Controls precision
 	- When set to \b ON, all calculations are performed in single precision.
 	- When set to \b OFF, all calculations are performed in double precision. 
 	- Must be set to \b ON to enable the \b USE_CUDA option (GPUs are single precision)
 - \b USE_CUDA - Enable compiling of the GPU accelerated computations using CUDA
 	- Requires the CUDA Toolkit to be installed
 - \b USE_PYTHON - Set to \b ON to enable the building of the python module.
 	- Required for the use of the high-level scripting system
 	- Requries python to be installed, and a matching version of boost.python.
 - \b USE_STATIC - Controls the compiling and linking of static libraries
 	- When set to \b ON, \b libhoomd is compiled as a static library and all 
 		other libraries (i.e. boost) are linked statically if possible.
 	- When set to \b OFF, \b libhoomd is compiled as a dynamic library and all
 		other libraries are linked dynamically if possible.
 	- Note: \b USE_STATIC=OFF is not supported on windows. 
 - \b USE_TEST - Enables building of unit tests and the "make test" target
 - \b USE_VALGRIND - (Linux only) Runs every unit test through valgrind for hardcore testing/debugging. If used with CUDA, device emulation mode is recommended.
 
There are a few options for controling the CUDA compilation.
 - \b CUDA_BUILD_CUBIN - Enables a display of register usage for each kernel compiled.
 - \b CUDA_BUILD_TYPE - Controls device/emulation builds
 	- \b Device - will compile all GPU kernels to run on the GPU hardware
 	- \b Emulation - will comiple all GPU kernels in a CPU emulation mode. 
 		This emulation mode is very slow, but does allow developers without 
 		G80 cards to compile and test changes to GPU-related code. Actual
 		kernel development is not recommended without a hardware device to 
 		run on.
 - \b NVCC_USER_FLAGS - Allows additional flags to be passed to nvcc.
 	- Recommended usage is to use this only for -DNDEBUG when compiling in 
 		Release mode. Without -DNDEBUG, there will be a sync and an error check
 		after every single kernel execution which is only useful for debugging.

*/
