from hoomd_script import *
import sys;
import math;

#########################
# test the table pair force by running a large liquid sim for a long time
# there are four types of particles that should phase separate over time

# by default, the test will run for roughly 2 hours on a Tesla C870
# if "endurance" is passed as the first argument on the command line, it will
# run for about 24 hours instead
#########################

# handle the endurance setting
endurance = False
if len(sys.argv) > 1 and sys.argv[1] == 'endurance':
	endurance = True
	del sys.argv[1]

# create 8000 particles of type A,B,C,D using the polymer generator
typeA = dict(bond_len=1.2, type=['A'], bond="linear", count=8000)
typeB = dict(bond_len=1.2, type=['B'], bond="linear", count=8000)
typeC = dict(bond_len=1.2, type=['C'], bond="linear", count=8000)
typeD = dict(bond_len=1.2, type=['D'], bond="linear", count=8000)

# perform some simple math to find the length of the box
N = len(typeA['type'])*typeA['count']*4;
phi_P = 0.25;
L = math.pow(math.pi * N / (6.0 * phi_P), 1.0/3.0);

# create the initial conditions
init.create_random_polymers(box=hoomd.BoxDim(L), polymers=[typeA, typeB, typeC, typeD], separation=dict(A=0.35, B=0.35, C=0.35, D=0.35))

# specify Lennard-Jones interactions between particle pairs
def lj(r, rmin, rmax, epsilon, sigma):
     V = 4 * epsilon * ( (sigma / r)**12 - (sigma / r)**6);
     V = V - 4 * epsilon * ( (sigma / rmax)**12 - (sigma / rmax)**6);
     F = 4 * epsilon / r * ( 12 * (sigma / r)**12 - 6 * (sigma / r)**6);
     return (V, F)

p = pair.table(width=1000)
p.pair_coeff.set('A', 'A', func=lj, rmin=0.8, rmax=2.5, coeff=dict(epsilon=1.0, sigma=1.0))
p.pair_coeff.set('A', 'B', func=lj, rmin=0.8, rmax=1.2, coeff=dict(epsilon=1.0, sigma=1.0))
p.pair_coeff.set('A', 'C', func=lj, rmin=0.8, rmax=1.2, coeff=dict(epsilon=1.0, sigma=1.0))
p.pair_coeff.set('A', 'D', func=lj, rmin=0.8, rmax=1.2, coeff=dict(epsilon=1.0, sigma=1.0))

p.pair_coeff.set('B', 'B', func=lj, rmin=0.8, rmax=2.5, coeff=dict(epsilon=1.0, sigma=1.0))
p.pair_coeff.set('B', 'C', func=lj, rmin=0.8, rmax=1.2, coeff=dict(epsilon=1.0, sigma=1.0))
p.pair_coeff.set('B', 'D', func=lj, rmin=0.8, rmax=1.2, coeff=dict(epsilon=1.0, sigma=1.0))

p.pair_coeff.set('C', 'C', func=lj, rmin=0.8, rmax=2.5, coeff=dict(epsilon=1.0, sigma=1.0))
p.pair_coeff.set('C', 'D', func=lj, rmin=0.8, rmax=1.2, coeff=dict(epsilon=1.0, sigma=1.0))

p.pair_coeff.set('D', 'D', func=lj, rmin=0.8, rmax=2.5, coeff=dict(epsilon=1.0, sigma=1.0))

# integrate at constant temperature
all = group.all()
integrate.mode_standard(dt=0.005)
integrate.nvt(all, tau=0.5, T=1.0)

# equilibrate
run(50000, profile=True)

# dump every 10k steps
mol2 = dump.mol2()
mol2.write(filename="dump.mol2");
dump.dcd(filename="dump.dcd", period=200000);

# log lj energy
analyze.log(filename="log.txt", quantities=['temperature', 'pressure', 'kinetic_energy', 'potential_energy', 'pair_table_energy'], period=1000)

# calculate and log msd
groupA = group.type('A')
groupB = group.type('B')
groupC = group.type('C')
groupD = group.type('D')
analyze.msd(filename='msd.txt', groups=[groupA, groupB, groupC, groupD], period=10000)

# run for a a couple hours
run(1e9, limit_hours=2)

if endurance:
	# run for a few more hours
	run(1e9, limit_hours=22)
